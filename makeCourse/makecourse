#!/usr/bin/env python
import argparse
import errno
import logging
import makeCourse.hackmd
import makeCourse.process
import makeCourse.pandoc
import os
import re
import shutil
import sys
import yaml
from distutils.dir_util import copy_tree
from makeCourse import *
from subprocess import Popen, PIPE 

logger = logging.getLogger('makeCourse')

class MakeCourse(object,makeCourse.process.CourseProcessor, makeCourse.pandoc.PandocRunner):

	mathjax_url = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'

	def __init__(self, args):
		self.args = args

		self.root_dir = args.dir

		if args.veryverbose:
			args.verbose = True

		if args.verbose:
			if args.veryverbose:
				logging.basicConfig(level=logging.DEBUG, format='%(filename)s:%(lineno)d: %(levelname)s:\t%(message)s')
			else:
				logging.basicConfig(level=logging.INFO, format='%(message)s')
		else:
			logging.basicConfig(level=logging.WARN, format='%(levelname)s: %(message)s\n')

		print("Running makecourse for directory {}".format(os.path.abspath(self.args.dir)))

	def load_config(self):
		if self.args.config_file:
			config_file = self.args.config_file
		else:
			config_file = os.path.join(self.root_dir, 'config.yml')

		logger.info("Reading config file {}".format(config_file))

		with open(config_file, 'r') as f:
			loaded_config = yaml.load(f)

		if 'configFile' in loaded_config:
			# the config file can specify a different config file to load, stored in HackMD
			realConfig = makeCourse.hackmd.getHackmdDocument(loaded_config,loaded_config['configFile'])
			realConfig = re.sub(r'^---.*?---\n','',realConfig,flags=re.S)
			loaded_config = yaml.load(realConfig)

		loaded_config['args'] = self.args

		config = {
			'themes_dir': os.path.join(self.root_dir,'themes'),
			'static_dir': os.path.join(self.root_dir,'static'),
			'build_dir': os.path.join(self.root_dir,'build'),
			'theme': 'default',
			'web_dir': '/module/'+loaded_config.get('code','') if 'code' in loaded_config else '/',
			'partsEnabled': False,
			'tempFiles': [],
			'build_pdf': True
		}

		config.update(loaded_config)
		self.config = config

		if self.args.theme:
			self.config['theme'] = self.args.theme

		if self.args.build_pdf is not None:
			self.config['build_pdf'] = self.args.build_pdf

		self.theme_dir = os.path.join(self.config['themes_dir'], self.config['theme'])

		logger.debug("""The themes directory is: {themes_dir}
The static directory is: {static_dir}
The build directory is: {build_dir}
The web directory is: {web_dir}""".format(**self.config))

	def cleanup(self):

		try:
			shutil.rmtree(os.path.join(self.root_dir,'tmp'))
		except OSError:
			pass

		logger.info("Cleaning up temporary files")
		for temp_file in self.config['tempFiles']:
			try:	# this should really check if the path is a dir first
				os.remove(os.path.join(self.root_dir,temp_file))
			except OSError:
				try:
					shutil.rmtree(os.path.join(self.root_dir,temp_file))
					logger.info('    Deleted: {}'.format(temp_file))
				except OSError:
					pass

		logger.info("Cleaning up any missed files")
		for f in os.listdir(self.root_dir):
			_,ext = os.path.splitext(f)
			if ext=='.paux':
				fpath = os.path.join(self.root_dir,f)
				os.remove(fpath)
				logger.info('    Deleted: {}'.format(fpath))

	def make_directories(self):
		logger.info("Creating build directory...")
		mkdir_p(self.config['build_dir'])
		mkdir_p(os.path.join(self.config['build_dir'],'static'))

		logger.info("Creating static directory...")
		mkdir_p(self.config['static_dir'])

	def process(self):
		logger.info("Starting processing...")
		self.doProcess()

	def copy_theme_static_files(self):
		srcPath = os.path.join(self.theme_dir,'static')
		dstPath = os.path.join(self.config['build_dir'],'static')
		logger.info("Copying Theme's static directory to the build's static directory...")
		logger.info("    {src} => {dest}".format(src=srcPath,dest=dstPath))
		try:
			copy_tree(srcPath, dstPath)
		except:
			logger.warning("Warning: Problem copying the theme's static files")

		logger.info("Copying course's static directory to the build's static directory...")
		srcPath = self.config['static_dir']
		dstPath = os.path.join(self.config['build_dir'],'static')
		logger.info("    {src} => {dest}".format(src=srcPath,dest=dstPath))
		try:
			copy_tree(srcPath, dstPath)
		except:
			logger.warning("Warning: Problem copying Course's static directory!")
	
	def get_mock_test(self):
		for item in self.config['structure']:
			if item.get('type','')=='mocktest':
				return item['source']
		

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument('-v', dest='verbose', action='store_true',help='verbose output')
	parser.add_argument('-vv', dest='veryverbose', action='store_true',help='very verbose output')
	parser.add_argument('-d', dest='deleteFirst', action='store_true',help='delete temporary files first')
	parser.add_argument('-l', dest='lazy', action='store_true',help='don\'t delete temporary files when finished')
	parser.add_argument('--no-pdf', dest='build_pdf', action='store_false',help='don\'t build PDF')
	parser.add_argument('--theme', dest='theme', help='Name of the theme to use')
	parser.add_argument('--config', dest='config_file', help='Path to config file')
	parser.add_argument('dir', help='a course definition directory', default='.', nargs='?')
	parser.set_defaults(build_pdf=None)
	args = parser.parse_args()

	mc = MakeCourse(args)
	
	mc.load_config()

	if mc.args.deleteFirst:
		mc.cleanup()

	mc.make_directories()

	mc.process()
	
	logger.info("Running epilogue...")

	mc.copy_theme_static_files()

	if not mc.args.lazy:
		mc.cleanup()
		
	print("All done! Output written to {}".format(mc.config['build_dir']))
if __name__ == "__main__":
	main()
