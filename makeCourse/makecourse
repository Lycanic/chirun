#!/usr/bin/env python

import logging
import plasTeX.Logging
logging.setLoggerClass(logging.Logger)

import argparse
import datetime
import errno
import makeCourse.plastex
import makeCourse.process
import makeCourse.pandoc
import makeCourse.latex
import makeCourse.decktape
import os
import re
import shutil
import sys
import yaml
from distutils.dir_util import copy_tree
from makeCourse import *
import makeCourse
from makeCourse.theme import *
from makeCourse import oembed
from pathlib import Path
from subprocess import Popen, PIPE
import logging

logger = logging.getLogger('makeCourse')


class MakeCourse:

    mathjax_url = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'

    def __init__(self, args):
        self.args = args

        self.root_dir = self.get_root_dir()

        if args.veryverbose:
            args.verbose = True

        if args.verbose:
            if args.veryverbose:
                logger.setLevel(logging.DEBUG)
                logging.basicConfig(format='%(name)s:%(funcName)s:%(lineno)d: %(levelname)s:\t%(message)s')
            else:
                logger.setLevel(logging.INFO)
                logging.basicConfig(format='%(message)s')

        print("Running makecourse for directory {}".format(self.get_root_dir().resolve()))

    def get_root_dir(self):
        """ 
            The path to the course's source directory 
        """
        return Path(self.args.dir)

    def get_build_dir(self):
        """
            The path the output will be put in
        """
        return self.get_root_dir() / 'build' / self.theme.path

    def get_static_dir(self):
        """
            The path to the course's static files source
        """
        return Path(self.config['static_dir'])

    def get_web_root(self, force_local=False):
        """
            The root URL of the course. All URLs are under this.
        """
        if self.args.local or force_local:
            return str(self.get_build_dir().resolve()) + '/'
        else:
            if 'root_url' in self.config:
                root = self.config.get('root_url')
            else:
                root = '/module'

            # TODO: add an option to turn off the code and year parts of the URL
            code = self.config.get('code')
            year = self.config.get('year')
            if code:
                root += '/' + self.config.get('code', '')
            if year:
                root += '/' + str(self.config.get('year', ''))

            root += '/' + self.theme.path + '/'
            return root

    def default_config(self):
        root_dir = self.get_root_dir()
        config = {
            'static_dir': root_dir / 'static',
            'build_pdf': True,
            'year': datetime.datetime.now().year,
        }
        return config

    def get_config_file(self):
        """
            The path to the config file
        """
        if self.args.config_file:
            return Path(self.args.config_file)
        else:
            return self.get_root_dir() / 'config.yml'

    def load_config(self):
        """
            Load the config.

            Extend the default config with the config loaded from the filesystem
        """
        config_file = self.get_config_file()

        logger.info("Reading config file {}".format(config_file))

        with open(str(config_file), 'r') as f:
            config = self.loaded_config = yaml.load(f)

        config['args'] = self.args

        self.config = self.default_config()
        self.config.update(self.loaded_config)

    def theme_directories(self):
        """
            An iterator for paths containing themes

            Tries:
                * The themes_dir path specified in the config
                * The directory 'themes' under the root directory of the course
                * The directory 'themes' in the makeCourse package
                * The directory 'themes' in the current working directory
        """
        if 'themes_dir' in self.config:
            yield Path(self.config.get('themes_dir'))
        yield self.get_root_dir() / 'themes'
        yield Path(__file__).parent / 'themes'
        yield Path('themes')

    def find_theme(self, name):
        """
            Find the source directory for the theme with the given name
        """
        logger.debug("Finding theme {}".format(name))
        for path in self.theme_directories():
            p = path / name
            logger.debug("Trying {}".format(p))
            if p.exists():
                return p

        raise Exception("Couldn't find theme {}".format(name))

    def load_themes(self):
        """
            Load every theme defined in the config
        """
        self.themes = []
        for theme_data in self.config['themes']:
            name = theme_data['source']
            source = self.find_theme(name)
            theme = Theme(self, name, source, theme_data)
            self.themes.append(theme)

    def cleanup(self):
        """
            Remove temporary files created during the build process
        """
        logger.info("Cleaning up temporary files")

        try:
            shutil.rmtree(str(self.get_root_dir() / 'tmp'))
        except OSError:
            pass

    def get_context(self):
        """
            A dictionary of context information about the course, for templates to use
        """
        return {
            'author': self.config['author'],
            'code': self.config['code'],
            'year': self.config['year'],
            'theme': self.theme.get_context(),
            'alt_themes': self.theme.alt_themes_contexts(),
        }
            

    def make_directories(self):
        """
            Make the output directory
        """
        logger.info("Creating build directory...")
        mkdir_p(self.get_build_dir())
        mkdir_p(self.get_build_dir() / 'static')

    def build_with_theme(self, theme):
        """
            Build the course using the given theme
        """
        self.theme = theme

        logger.debug("""
The static directory is: {static_dir}
The build directory is: {build_dir}
The web root directory is: {web_root}
""".format(
            static_dir=self.get_static_dir(),
            build_dir=self.get_build_dir(),
            web_root=self.get_web_root(),
        ))

        self.make_directories()
        theme.copy_static_files()
        self.process()

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output')
    parser.add_argument('-vv', dest='veryverbose', action='store_true', help='very verbose output')
    parser.add_argument('-d', dest='deleteFirst', action='store_true', help='delete temporary files first')
    parser.add_argument('-z', dest='lazy', action='store_true', help='don\'t delete latex aux files when finished')
    parser.add_argument('-l', dest='local', action='store_true', help='create with local file paths')
    parser.add_argument('--config', dest='config_file', help='Path to config file')
    parser.add_argument('dir', help='a course definition directory', default='.', nargs='?')
    parser.set_defaults(build_pdf=None)
    args = parser.parse_args()

    return args


def main():
    args = parse_args()

    extensions = [
        makeCourse.plastex.PlastexRunner,
        makeCourse.process.CourseProcessor,
        makeCourse.decktape.DecktapeRunner,
    ]

    class Builder(MakeCourse, *extensions):
        pass

    oembed.load_cache()

    mc = Builder(args)

    mc.load_config()

    mc.load_themes()

    if args.deleteFirst:
        mc.cleanup()

    for theme in mc.themes:
        mc.build_with_theme(theme)

    if not mc.args.lazy:
        mc.cleanup()

    oembed.save_cache()

    print("All done! Output written to {}".format(mc.get_build_dir()))


if __name__ == "__main__":
    main()
